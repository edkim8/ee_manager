# Parser Engine Playground - AI Reference Guide

> **For AI Agents**: This document describes the Parser Engine Playground tool for parsing Excel/CSV files. Use this to understand capabilities, generate parsers, and help users configure file parsing.

## Overview

The **Parser Engine Playground** is an interactive tool located at:
```
layers/parsing/pages/playground/parser.vue
URL: /playground/parser
```

### Purpose
1. **Temporary Parsing**: Upload any Excel/CSV file, configure mappings, and parse to JSON on-the-fly
2. **Parser Generation**: Create dedicated `useParser{ID}.ts` composables for production use
3. **Live Preview**: See transformed data in real-time before committing to parse

---

## Core Concepts

### 1. Strategies

| Strategy | Use Case | Behavior |
|----------|----------|----------|
| `standard` | Simple files with headers in row 1 | Direct header → field mapping |
| `yardi_report` | Files with property subheadings like "City View(cacitvie)" | Two-pass: extracts apt_code from subheadings, applies to subsequent rows |
| `fill_down` | Grouped data where cells inherit from above | Empty cells get value from previous row |

### 2. Transforms

| Transform | Input → Output | Example |
|-----------|----------------|---------|
| `none` | Raw value (no transform) | "Hello" → "Hello" |
| `skip` | Ignore column entirely | Column not included in output |
| `currency` | Parse currency strings | "$1,234.56" → 1234.56 |
| `date` | Normalize to yyyy-MM-dd | "1/15/24" → "2024-01-15" |
| `phone` | Extract digits only | "(555) 123-4567" → "5551234567" |
| `trim` | Remove whitespace | "  hello  " → "hello" |
| `yardi_code` | Yardi ID to property code | "azres422" → "RS" |

### 3. Merge Groups

Combine multiple columns into one field (first non-null wins):

```
Column: Tel_O  → mergeGroup: "phone", mergePriority: 1
Column: Tel_H  → mergeGroup: "phone", mergePriority: 2
Column: Tel_M  → mergeGroup: "phone", mergePriority: 3

Result: phone = first non-null value by priority
```

### 4. Fill Down

For grouped data where parent values span multiple rows:

```
| Property | Unit | Resident |
|----------|------|----------|
| ABC      | 101  | John     |
|          | 102  | Jane     |  ← Property is empty, fills from above
|          | 103  | Bob      |  ← Property is empty, fills from above
| XYZ      | 201  | Alice    |
```

With `fillDown: true` on Property, all rows get the correct property code.

---

## File Structure

```
layers/parsing/
├── composables/
│   ├── useGenericParser.ts      # Core parsing engine
│   └── parsers/                  # Generated dedicated parsers
│       ├── useParseApplications.ts
│       ├── useParseExpiringLeases.ts
│       └── ...
├── pages/
│   └── playground/
│       └── parser.vue            # The Playground UI
├── types/
│   └── index.ts                  # ParserConfig, FieldMapping, etc.
├── utils/
│   ├── formatters.ts             # parseCurrency, formatDateForDB, yardiToPropertyCode
│   └── helpers.ts                # getApartmentCode, normalizeHeader
└── docs/
    └── PARSER_PLAYGROUND.md      # This file
```

---

## Using the Playground

### Step-by-Step Workflow

1. **Upload File**
   - Accepts .xlsx, .xls, .csv
   - Auto-detects headers from configured row
   - Shows raw preview with first 10 rows

2. **Configure Parser Settings**
   - **Parser ID**: Snake_case identifier (e.g., `expiring_leases`)
   - **Strategy**: Choose based on file structure
   - **Header Row**: 1-based index where headers are located
   - **Filename Pattern**: Regex to validate file names

3. **Map Headers**
   - Each detected header gets a mapping card
   - Set **Target Field** (output field name)
   - Choose **Transform** from dropdown
   - Enable **Required** to filter out incomplete rows
   - Enable **Fill↓** for fill-down behavior
   - Set **Merge Group** + **Priority** to combine columns

4. **Live Preview**
   - See transformed values in real-time
   - Green checkmark indicates successful transform
   - Purple cells show fill-down values
   - Invalid rows (missing required fields) shown in red

5. **Parse File**
   - Click "Parse File" to run full parse
   - View results in "Parsed Data" tab
   - Check summary statistics and group-by breakdown

6. **Export as Parser**
   - Click "Export Parser" tab
   - Review generated TypeScript code
   - Click "Download .ts" to save file
   - Place in `layers/parsing/composables/parsers/`

---

## Generated Parser Structure

```typescript
/**
 * Auto-generated by Parser Engine Playground
 * Parser: expiring_leases
 * Generated: 2026-01-24
 */

import { useGenericParser } from '../useGenericParser'
import type { ParserConfig, ParsedResult } from '../../types'

export interface ExpiringLeasesRow {
  unit_code: string | null
  resident_name: string | null
  lease_to_date: string | null
  apt_code: string | null
  unit_id?: string | null
  unique_id?: string
}

const config: ParserConfig = {
  id: 'expiring_leases',
  namePattern: '5p_ExpiringLeases',
  headerRow: 4,
  strategy: 'yardi_report',
  mapping: {
    'Unit': { targetField: 'unit_code', transform: 'trim' },
    'Resident Name': { targetField: 'resident_name' },
    'Lease To': { targetField: 'lease_to_date', transform: 'date', required: true }
  },
  getUniqueId: (row) => `${row.apt_code || ''}_${row.lease_to_date || ''}`
}

export async function useParseExpiringLeases(
  file: File,
  options?: { unitsLookup?: Array<{ apt_code: string; name: string; unit_id: string }> }
): Promise<ParsedResult<ExpiringLeasesRow>> {
  return useGenericParser<ExpiringLeasesRow>(file, config, options)
}

export const expiring_leasesConfig = config
```

---

## Yardi Property Code Dictionary

Located in `utils/formatters.ts`:

```typescript
const YARDI_TO_PROPERTY_CODE: Record<string, string> = {
  'azstoran': 'SB',  // Stonebridge
  'azres422': 'RS',  // Residences
  'caoceabr': 'OB',  // Ocean Breeze
  'cacitvie': 'CV',  // City View
  'cawhioak': 'WO',  // Whispering Oaks
}
```

**Note**: This dictionary is sparse. Add new mappings as properties are onboarded.

---

## Common Patterns

### Pattern 1: Simple Report (Standard Strategy)
```
File: 5p_Applications.xlsx
Headers on Row 1
Direct mapping, no subheadings
```
→ Use `strategy: 'standard'`

### Pattern 2: Yardi Multi-Property Report
```
File: 5p_ExpiringLeases.xlsx
Headers on Row 4
Property subheadings like "City View(cacitvie) - Expiring Leases"
Data rows follow each subheading
```
→ Use `strategy: 'yardi_report'`

### Pattern 3: Grouped Data with Empty Parent Cells
```
File: Rent_Roll.xlsx
Property column only has value in first row of group
Subsequent rows have empty Property cell
```
→ Use `strategy: 'fill_down'` or per-field `fillDown: true`

---

## API Reference

### useGenericParser

```typescript
async function useGenericParser<T>(
  file: File,
  config: ParserConfig,
  options?: {
    unitsLookup?: Array<{ apt_code: string; name: string; unit_id: string }>
    groupByFields?: string[]
  }
): Promise<ParsedResult<T>>
```

### ParserConfig

```typescript
interface ParserConfig {
  id: string
  namePattern: string              // Regex for filename validation
  headerRow?: number               // 1-based (default: 1)
  strategy: 'standard' | 'yardi_report' | 'fill_down'
  fillDownFields?: string[]        // For fill_down strategy
  mapping: Record<string, FieldMapping>
  computedFields?: Record<string, (row: any) => any>
  getUniqueId?: (row: any) => string
}
```

### FieldMapping

```typescript
interface FieldMapping {
  targetField: string
  transform?: 'currency' | 'date' | 'phone' | 'trim' | 'yardi_code' | 'skip' | ((val, row) => any)
  required?: boolean
  fillDown?: boolean
  mergeGroup?: string
  mergePriority?: number
}
```

### ParsedResult

```typescript
interface ParsedResult<T> {
  data: T[]
  errors: string[]
  meta: {
    filename: string
    totalRows: number
    parsedRows: number
    groupBy?: Record<string, Record<string, number>>
  }
}
```

---

## Troubleshooting

| Issue | Cause | Solution |
|-------|-------|----------|
| "No data" in dropdown | Empty string item ID | Use `'none'` instead of `''` |
| Date shows timestamp | Transform not applied | Select "Date" transform |
| Yardi code not converted | Not in dictionary | Add to `YARDI_TO_PROPERTY_CODE` |
| Rows filtered unexpectedly | Required field empty | Check required field mappings |
| apt_code missing | Wrong strategy | Use `yardi_report` for property subheadings |

---

## Best Practices for AI Agents

1. **Always check file structure first** - Determine strategy based on subheadings and grouping
2. **Use Live Preview** - Verify transforms work before full parse
3. **Set Required fields carefully** - These filter rows, not just validate
4. **Test with sample data** - The 3-row preview catches most issues
5. **Export and customize** - Generated parsers are starting points, customize as needed

---

## Related Files

- Core Engine: `layers/parsing/composables/useGenericParser.ts`
- Type Definitions: `layers/parsing/types/index.ts`
- Formatters: `layers/parsing/utils/formatters.ts`
- Helpers: `layers/parsing/utils/helpers.ts`
- Playground UI: `layers/parsing/pages/playground/parser.vue`
