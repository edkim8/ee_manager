import nodemailer from 'nodemailer'
import { serverSupabaseServiceRole } from '#supabase/server'
import { Database } from '../../../../../types/supabase'

function generateAuditHtml(content: string, date: string, batchId: string): string {
  // Apply inline markdown transforms (bold, inline code) to a text string
  function applyInline(text: string): string {
    return text
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/`(.+?)`/g, '<code>$1</code>')
  }

  // Detect a markdown separator row: |---|---| or |:---|---:|
  function isSeparatorRow(line: string): boolean {
    const cells = line.trim().slice(1, -1).split('|')
    return cells.every(cell => /^[\s:|-]+$/.test(cell))
  }

  // Render a collected block of consecutive pipe-lines as a styled <table>
  function renderTable(tableLines: string[]): string {
    const dataLines = tableLines.filter(l => !isSeparatorRow(l))
    if (dataLines.length === 0) return ''

    const parseRow = (line: string): string[] =>
      line.trim().slice(1, -1).split('|').map(cell => cell.trim())

    const [headerLine, ...bodyLines] = dataLines
    const headers = parseRow(headerLine)

    const headerHtml = headers
      .map(h => `<th>${applyInline(h)}</th>`)
      .join('')

    const bodyHtml = bodyLines
      .map((row, idx) => {
        const cells = parseRow(row)
        const bg = idx % 2 === 0 ? '#f8fafc' : '#ffffff'
        return `<tr>${cells.map(c => `<td style="background:${bg}">${applyInline(c)}</td>`).join('')}</tr>`
      })
      .join('\n')

    return `<table class="audit-table"><thead><tr>${headerHtml}</tr></thead><tbody>${bodyHtml}</tbody></table>`
  }

  // Block-based processing — groups consecutive pipe lines into tables
  const lines = content.split('\n')
  const parts: string[] = []
  let i = 0

  while (i < lines.length) {
    const line = lines[i]

    // Table block: collect all consecutive | lines
    if (line.trim().startsWith('|')) {
      const tableLines: string[] = []
      while (i < lines.length && lines[i].trim().startsWith('|')) {
        tableLines.push(lines[i])
        i++
      }
      parts.push(renderTable(tableLines))
      continue
    }

    // Headers
    if (line.startsWith('### ')) { parts.push(`<h3>${applyInline(line.slice(4))}</h3>`); i++; continue }
    if (line.startsWith('## '))  { parts.push(`<h2>${applyInline(line.slice(3))}</h2>`);  i++; continue }
    if (line.startsWith('# '))   { parts.push(`<h1>${applyInline(line.slice(2))}</h1>`);   i++; continue }

    // Horizontal rule
    if (line.trim() === '---') { parts.push('<hr>'); i++; continue }

    // Blank line
    if (line.trim() === '') { parts.push('<br>'); i++; continue }

    // Default paragraph
    parts.push(`<p style="margin:2px 0">${applyInline(line)}</p>`)
    i++
  }

  return `<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; color: #1a1a2e; background: #f8f9fa; margin: 0; padding: 20px; }
  .container { max-width: 860px; margin: 0 auto; background: #ffffff; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
  .header { background: #1a1a2e; color: #ffffff; padding: 24px 32px; }
  .header h1 { margin: 0; font-size: 20px; font-weight: 600; }
  .header p { margin: 4px 0 0; font-size: 13px; color: #94a3b8; }
  .body { padding: 24px 32px; }
  h1 { font-size: 20px; color: #1a1a2e; margin: 20px 0 8px; }
  h2 { font-size: 16px; color: #1e40af; border-bottom: 1px solid #e2e8f0; padding-bottom: 4px; margin: 20px 0 8px; }
  h3 { font-size: 14px; color: #374151; margin: 14px 0 4px; }
  hr { border: none; border-top: 1px solid #e2e8f0; margin: 16px 0; }
  p { font-size: 13px; line-height: 1.6; color: #374151; }
  code { font-family: 'SFMono-Regular', Consolas, monospace; font-size: 12px; background: #f1f5f9; padding: 1px 4px; border-radius: 3px; color: #0f172a; }
  strong { color: #111827; }
  .audit-table { width: 100%; border-collapse: collapse; margin: 10px 0 16px; font-size: 12px; }
  .audit-table thead tr { background: #1e40af; }
  .audit-table th { color: #ffffff; padding: 7px 10px; text-align: left; font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: 0.04em; }
  .audit-table td { padding: 6px 10px; border-bottom: 1px solid #e2e8f0; color: #374151; vertical-align: top; }
  .audit-table tbody tr:last-child td { border-bottom: none; }
  .footer { padding: 16px 32px; background: #f8f9fa; border-top: 1px solid #e2e8f0; font-size: 11px; color: #9ca3af; }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Daily Solver Audit — ${date}</h1>
    <p>Batch: ${batchId} &nbsp;|&nbsp; Tier 2 Data Architect Report</p>
  </div>
  <div class="body">
    ${parts.join('\n')}
  </div>
  <div class="footer">
    Generated by EE Manager &nbsp;|&nbsp; Automated Audit System
  </div>
</div>
</body>
</html>`
}

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { content, date, batchId } = body

  if (!content || !date) {
    throw createError({ statusCode: 400, statusMessage: 'Missing content or date' })
  }

  const config = useRuntimeConfig()
  const client = serverSupabaseServiceRole<Database>(event)

  try {
    // Fetch all active audit recipients, deduplicated by email
    const { data: recipients, error: recError } = await client
      .from('property_notification_recipients')
      .select('email')
      .eq('is_active', true)
      .contains('notification_types', ['audit'])

    if (recError) throw recError
    if (!recipients || recipients.length === 0) {
      return { success: true, message: 'No audit recipients configured' }
    }

    // Deduplicate emails (a user may have 'audit' on multiple property rows)
    const uniqueEmails = [...new Set(recipients.map(r => r.email))]

    const transporter = nodemailer.createTransport({
      host: config.public.mailersendServer,
      port: parseInt(config.public.mailersendPort as string),
      auth: {
        user: config.public.mailersendUsername,
        pass: config.mailersendPassword
      }
    })

    const htmlContent = generateAuditHtml(content, date, batchId || 'N/A')
    const results = []

    for (const email of uniqueEmails) {
      try {
        await transporter.sendMail({
          from: `"${config.public.mailersendSmtpName || 'EE Manager'}" <${config.public.mailersendUsername || 'noreply@ee-manager.com'}>`,
          to: email,
          subject: `Daily Audit Report — ${date}`,
          html: htmlContent
        })
        results.push({ email, status: 'sent' })
      } catch (sendError: any) {
        console.error(`[Audit Email] Failed to send to ${email}:`, sendError)
        results.push({ email, status: 'failed', error: sendError.message })
      }
    }

    return { success: true, results }
  } catch (error: any) {
    console.error('[Audit Email API] Error:', error)
    throw createError({ statusCode: 500, statusMessage: error.message || 'Internal Server Error' })
  }
})
